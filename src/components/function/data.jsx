export const data = [
  {
    id: 1,
    category: 1,
    name: "HTML",
    ComponentName: "Html",
    path: "html",
    nextPath: "/css",
    data: [
      {
        title: "Теги",
        desc: "Теги в HTML используются для разметки и определения структуры и содержания веб-страницы.",
      },
      {
        title: "Aтрибут",
        desc: "Атрибуты в HTML — это дополнительные параметры, которые можно добавить к тегам для определения их поведения или внешнего вида.",
      },
      {
        title: "Link",
        desc: "HTML-элемент, который используется для связывания внешних ресурсов с HTML-документом.",
      },
      {
        title: "script",
        desc: " <script> используется для внедрения и выполнения JavaScript-кода на веб-странице.",
      },
      {
        title: "<!DOCTYPE html>",
        desc: "DOCTYPE - это декларация, которая размещается в начале HTML-документа и сообщает браузеру, что документ написан в стандарте HTML5.",
      },
    ],
  },
  {
    id: 2,
    category: 2,
    name: "CSS",
    ComponentName: "Css",
    path: "css",
    nextPath: "/js/varible",
    data: [
      {
        title: "display",
        desc: `Свойство display в CSS используется для определения типа отображения элемента на странице и его поведения в контексте потока документа. Это ключевое свойство для управления макетом элементов.`,
      },
      {
        title: "Псевдоэлементы",
        desc: 'Псевдоэлементы - используются для добавления стилей к частям элемента или создания новых визуальных элементов, которые не существуют в исходном HTML. Они начинаются с двойного двоеточия "::"',
      },
      {
        title: "Псевдоклассы",
        desc: `Псевдоклассы применяются к элементам на основе их состояния или положения в документе. Они начинаются с двоеточия ":"`,
      },
      {
        title: "Grid ",
        desc: `предназначен для двумерных макетов, где требуется управление как строками, так и колонками. Grid позволяет создавать более сложные и структурированные макеты.`,
      },
      {
        title: "Flexbox",
        desc: `предназначен для одномерных макетов (например, строка или колонка) и работает отлично для выравнивания и распределения пространства внутри одного направления.`,
      },
      {
        title: "none",
        desc: `свойство которое работает для удаление элемента из поля видимости`,
      },
    ],
  },
  {
    id: 3,
    category: 3,
    name: "Переменные",
    ComponentName: "Varible",
    path: "varible",
    nextPath: "/js/data",
    data: [
      {
        title: "var",
        desc: `var - имеет функциональную область видимости (function scope), что означает, что переменная доступна в пределах функции, где она объявлена, или глобально, если объявлена вне функции. var игнорирует блоки кода (например, блоки {} внутри if или for).`,
      },
      {
        title: "let",
        desc: `let имеет блочную область видимости (block scope), что означает, что переменная доступна только внутри блока кода, где она была объявлена.`,
      },
      {
        title: "const",
        desc: `Используется для объявлений неизменяемых переменных (неизменяемость относится только к ссылке на объект, но не к содержимому объекта)`,
      },
    ],
  },
  {
    id: 4,
    category: 3,
    name: "Типы данных",
    ComponentName: "Data",
    path: "data",
    nextPath: "/js/operators",
    data: [
      {
        title: "number",
        desc: "Хранит числовые значения, как целые, так и с плавающей запятой.",
      },
      {
        title: "string",
        desc: `Хранит строки текста. Строки могут быть заключены в одинарные ('), двойные (")`,
      },
      {
        title: "boolean",
        desc: `Хранит логические значения true или false.`,
      },
      {
        title: `undefined`,
        desc: `Значение по умолчанию для переменных, которые были объявлены, но не инициализированы. Также возвращается функцией, которая ничего не возвращает.`,
      },
      {
        title: `null`,
        desc: `Является явным указанием на отсутствие значения или объект. Оно часто используется для инициализации переменных, которые будут позже заполнены значением.`,
      },
      {
        title: `symbol`,
        desc: `Хранит уникальные и неизменяемые идентификаторы, часто используются в качестве ключей для свойств объектов.`,
      },
      {
        title: `bigint`,
        desc: `Хранит целые числа произвольной длины. Это полезно для работы с числами, которые выходят за пределы диапазона обычных чисел.`,
      },
      {
        title: `object`,
        desc: `Хранит коллекцию пар "ключ-значение". Объекты могут быть использованы для создания более сложных структур данных`,
      },
    ],
  },
  {
    id: 5,
    category: 3,
    ComponentName: "Operators",
    name: "Операторы",
    path: "operators",
    nextPath: "/js/loop",
    data: [
      {
        title: "Арифметические операторы",
        desc: `Арифметические операторы используются для выполнения математических операций над числами. 
                 Основные арифметические операторы включают:
                 - \`+\` (плюс): сложение
                 - \`-\` (минус): вычитание
                 - \`*\` (умножение): умножение
                 - \`/\` (деление): деление
                 - \`%\` (остаток от деления): деление с остатком
                 - \`**\` (возведение в степень): возведение числа в степень.`,
      },
      {
        title: "Операторы сравнения",
        desc: `Операторы сравнения используются для сравнения двух значений и возвращают булевое значение (\`true\` или \`false\`).
                 Основные операторы сравнения включают:
                 - \`==\` (равенство): проверяет, равны ли два значения, игнорируя тип
                 - \`===\` (строгое равенство): проверяет, равны ли два значения, включая тип
                 - \`!=\` (неравенство): проверяет, не равны ли два значения, игнорируя тип
                 - \`!==\` (строгое неравенство): проверяет, не равны ли два значения, включая тип
                 - \`>=\` (больше или равно): проверяет, больше ли или равно ли одно значение другому
                 - \`<=\` (меньше или равно): проверяет, меньше ли или равно ли одно значение другому.`,
      },
      {
        title: "Логические операторы",
        desc: `Логические операторы используются для комбинирования логических значений и возвращают логический результат.
                 Основные логические операторы включают:
                 - \`&&\` (логическое И): возвращает \`true\`, если оба операнда истинны
                 - \`||\` (логическое ИЛИ): возвращает \`true\`, если хотя бы один из операндов истинен
                 - \`!\` (логическое НЕ): возвращает \`true\`, если операнд ложен, и \`false\`, если операнд истинен.`,
      },
      {
        title: "Операторы присваивания",
        desc: `Операторы присваивания используются для присваивания значений переменным и могут выполнять дополнительные операции.
                 Основные операторы присваивания включают:
                 - \`=\` (присваивание): присваивает значение переменной
                 - \`+=\` (прибавить и присвоить): прибавляет значение к текущему значению переменной и присваивает результат
                 - \`-=\` (вычесть и присвоить): вычитает значение из текущего значения переменной и присваивает результат
                 - \`*=\` (умножить и присвоить): умножает текущее значение переменной на заданное значение и присваивает результат
                 - \`/=\` (разделить и присвоить): делит текущее значение переменной на заданное значение и присваивает результат
                 - \`%=\` (остаток от деления и присвоить): находит остаток от деления текущего значения переменной на заданное значение и присваивает результат.`,
      },
      {
        desc: `Операторы инкремента и декремента используются для увеличения или уменьшения значения переменной на единицу.
                 Основные операторы включают:
                 - \`++\` (инкремент): увеличивает значение переменной на единицу
                 - \`--\` (декремент): уменьшает значение переменной на единицу
                 Операторы могут быть использованы в постфиксной (например, \`x++\`) или префиксной (например, \`++x\`) форме.`,
      },
      {
        title: "Тернарный оператор",
        desc: `Тернарный оператор — это короткая форма записи условного выражения. Он имеет три операнда и возвращает значение в зависимости от условия.
                 Формат: \`условие ? значение_если_true : значение_если_false\`.
      
                 Пример: \`let result = (a > b) ? 'a больше b' : 'a не больше b';\``,
      },
    ],
  },
  {
    id: 6,
    category: 3,
    ComponentName: "Loop",
    name: "Циклы",
    path: "loop",
    nextPath: "/js/func",
    data: [
      {
        title: "Цикл `for`",
        desc: `Цикл \`for\` используется для выполнения блока кода несколько раз, пока условие истинно. Он включает три части: инициализацию, условие и итерацию.`,
      },
      {
        title: "Цикл `while`",
        desc: `Цикл \`while\` выполняет блок кода, пока указанное условие истинно. Если условие изначально ложно, код в цикле может не выполниться ни разу.`,
      },
      {
        title: "Цикл `do...while`",
        desc: `Цикл \`do...while\` похож на цикл \`while\`, но гарантирует, что блок кода выполнится хотя бы один раз, даже если условие ложно.`,
      },
      {
        title: "Цикл `for...in`",
        desc: `Цикл \`for...in\` используется для перебора свойств объекта. Он перебирает все перечисляемые свойства объекта, включая унаследованные свойства.`,
      },
      {
        title: "Цикл `for...of`",
        desc: `Цикл \`for...of\` используется для перебора элементов коллекций, таких как массивы, строки, карты и множества. Он перебирает значения, а не ключи.`,
      },
      {
        title: "Рекурсия",
        desc: `Рекурсия — это техника программирования, когда функция вызывает саму себя. Это полезно для решения задач, которые можно разбить на подобные подзадачи. Основные элементы рекурсии включают базовый случай, при котором рекурсия прекращается, и рекурсивный случай, где функция вызывает сама себя.`,
      },
    ],
  },
  {
    id: 7,
    category: 3,
    ComponentName: "Func",
    name: "Функция",
    path: "func",
    nextPath: "/js/obj",
    data: [
      {
        title: "Функции",
        desc: `Функции в JavaScript — это блоки кода, которые можно вызывать по имени, чтобы выполнить определённую задачу. Функции помогают организовать код, избегать повторений и улучшать читаемость.`,
      },
      {
        title: "Функции объявленные с помощью function",
        desc: `Функции, объявленные с помощью ключевого слова \`function\`, имеют функциональную область видимости и могут быть вызваны до их объявления (подъём функции). Такие функции могут быть объявлены и вызваны в любой части программы.`,
      },
      {
        title: "Стрелочные функции",
        desc: `Стрелочные функции, введённые в ES6, предоставляют короткий синтаксис для написания функций. Они не имеют собственного контекста \`this\`, что полезно в некоторых случаях. Формат: \`(параметры) => выражение\`.`,
      },
      {
        title: "Замыкания",
        desc: `Замыкания — это функция, которая сохраняет доступ к переменным своей внешней функции даже после того, как внешняя функция завершила выполнение. Это позволяет создавать функции с приватными данными.`,
      },
      {
        title: "Рекурсивные функции",
        desc: `Рекурсивные функции — это функции, которые вызывают сами себя. Они полезны для решения задач, которые можно разбить на подзадачи, аналогичные основной задаче.`,
      },
      {
        title: "Функции обратного вызова (callback functions)",
        desc: `Функции обратного вызова — это функции, передаваемые в другие функции в качестве аргументов. Они вызываются по завершению какого-либо действия или события.`,
      },
      {
        title: "Оператор spread",
        desc: `Оператор \`...\` (spread) позволяет разворачивать элементы массива или объекта в места, где ожидаются нуль или более аргументов (для массивов) или пар ключ-значение (для объектов).`,
      },
      {
        title: "REST-оператор",
        desc: `REST-оператор \`...\` (rest) используется для сбора оставшихся аргументов функции в массив. Он позволяет собирать неопределённое количество аргументов в функции в один массив. REST-оператор применяется в определении функции и указывается в конце списка параметров.`,
      },
    ],
  },
  {
    id: 8,
    category: 3,
    ComponentName: "Obj",
    name: "Объект",
    path: "obj",
    nextPath: "/js/array",
    data: [
      {
        title: "Объекты",
        desc: `Объекты в JavaScript — это коллекции пар "ключ-значение". Ключи (или свойства) могут быть строками или символами, а значения могут быть любого типа данных. Объекты позволяют хранить связанные данные и функции, которые работают с этими данными.`,
      },
      {
        title: "Создание объектов",
        desc: `Объекты можно создавать различными способами:
                 - С помощью литерала объекта: \`const obj = { ключ1: значение1, ключ2: значение2 };\`
                 - С помощью конструктора \`Object\`: \`const obj = new Object();\``,
      },
      {
        title: "Метод `Object.keys()`",
        desc: `Метод \`Object.keys(obj)\` возвращает массив строк, содержащих имена всех собственных перечисляемых свойств объекта \`obj\`. Этот метод полезен для перебора свойств объекта.`,
      },
      {
        title: "Метод `Object.values()`",
        desc: `Метод \`Object.values(obj)\` возвращает массив значений всех собственных перечисляемых свойств объекта \`obj\`. Он позволяет получить все значения свойств объекта без их ключей.`,
      },
      {
        title: "Метод `Object.entries()`",
        desc: `Метод \`Object.entries(obj)\` возвращает массив массивов, где каждый внутренний массив содержит ключ и значение одного собственного перечисляемого свойства объекта \`obj\`. Это удобно для перебора пар ключ-значение.`,
      },
      {
        title: "Метод `Object.assign()`",
        desc: `Метод \`Object.assign(target, ...sources)\` копирует значения всех собственных перечисляемых свойств из одного или нескольких исходных объектов в целевой объект. Возвращает целевой объект. Используется для объединения объектов или копирования свойств.`,
      },
      {
        title: "Метод `Object.freeze()`",
        desc: `Метод \`Object.freeze(obj)\` предотвращает изменение существующих свойств объекта \`obj\` и добавление новых свойств. Объект становится "замороженным", и любые попытки изменить его вызовут ошибку в строгом режиме.`,
      },
      {
        title: "Метод `Object.seal()`",
        desc: `Метод \`Object.seal(obj)\` предотвращает добавление новых свойств к объекту \`obj\` и делает все существующие свойства не настраиваемыми. Существующие свойства можно изменять, но не удалять.`,
      },
      {
        title: "Метод `Object-hasOwnProperty()`",
        desc: `Метод \`obj.hasOwnProperty(key)\` проверяет, есть ли у объекта \`obj\` собственное перечисляемое свойство с именем \`key\`. Возвращает \`true\`, если такое свойство существует, и \`false\` в противном случае.`,
      },
    ],
  },
  {
    id: 9,
    category: 3,
    ComponentName: "Arr",
    name: "Массив",
    path: "array",
    nextPath: "/js/json",
    data: [
      {
        title: "Массивы",
        desc: `Массивы в JavaScript — это объекты, представляющие собой упорядоченные коллекции значений. Они могут содержать элементы любых типов данных и имеют числовые индексы для доступа к этим элементам.`,
      },
      {
        title: "Создание массивов",
        desc: `Массивы можно создавать различными способами:
                 - С помощью литерала массива: \`const arr = [1, 2, 3];\`
                 - С помощью конструктора \`Array\`: \`const arr = new Array(3);\` (создаёт массив с 3 неинициализированными элементами).`,
      },
      {
        title: "Метод `Array.isArray()`",
        desc: `Метод \`Array.isArray(value)\` проверяет, является ли переданное значение массивом. Возвращает \`true\`, если значение является массивом, и \`false\` в противном случае.`,
      },
      {
        title: "Метод `Array.push()`",
        desc: `Метод \`Array.push(...items)\` добавляет один или несколько элементов в конец массива и возвращает новую длину массива.`,
      },
      {
        title: "Метод `Array.pop()`",
        desc: `Метод \`Array.pop()\` удаляет последний элемент из массива и возвращает его. Изменяет длину массива.`,
      },
      {
        title: "Метод `Array.shift()`",
        desc: `Метод \`Array.shift()\` удаляет первый элемент из массива и возвращает его. Изменяет длину массива.`,
      },
      {
        title: "Метод `Array.unshift()`",
        desc: `Метод \`Array.unshift(...items)\` добавляет один или несколько элементов в начало массива и возвращает новую длину массива.`,
      },
      {
        title: "Метод `Array.concat()`",
        desc: `Метод \`Array.concat(...arrays_or_values)\` объединяет два или более массива в один новый массив. Не изменяет исходные массивы.`,
      },
      {
        title: "Метод `Array.slice()`",
        desc: `Метод \`Array.slice(start, end)\` возвращает новый массив, содержащий копию части исходного массива, начиная с индекса \`start\` и заканчивая индексом \`end\` (не включая его). Исходный массив не изменяется.`,
      },
      {
        title: "Метод `Array.splice()`",
        desc: `Метод \`Array.splice(start, deleteCount, ...items)\` изменяет содержимое массива, удаляя или заменяя существующие элементы и/или добавляя новые элементы. Возвращает массив удалённых элементов.`,
      },
      {
        title: "Метод `Array.forEach()`",
        desc: `Метод \`Array.forEach(callback, thisArg)\` выполняет предоставленную функцию один раз для каждого элемента массива. Не возвращает ничего.`,
      },
      {
        title: "Метод `Array.map()`",
        desc: `Метод \`Array.map(callback, thisArg)\` создаёт новый массив с результатами вызова предоставленной функции для каждого элемента массива. Не изменяет исходный массив.`,
      },
      {
        title: "Метод `Array.filter()`",
        desc: `Метод \`Array.filter(callback, thisArg)\` создаёт новый массив с элементами, которые прошли проверку предоставленной функции. Не изменяет исходный массив.`,
      },
      {
        title: "Метод `Array.reduce()`",
        desc: `Метод \`Array.reduce(callback, initialValue)\` выполняет функцию редукции для каждого элемента массива, от первого к последнему, и возвращает одно итоговое значение. \`initialValue\` является необязательным.`,
      },
      {
        title: "Метод `Array.find()`",
        desc: `Метод \`Array.find(callback, thisArg)\` возвращает первый элемент массива, который удовлетворяет предоставленной функции, или \`undefined\`, если ни один элемент не соответствует.`,
      },
      {
        title: "Метод `Array.findIndex()`",
        desc: `Метод \`Array.findIndex(callback, thisArg)\` возвращает индекс первого элемента массива, который удовлетворяет предоставленной функции, или \`-1\`, если ни один элемент не соответствует.`,
      },
      {
        title: "Метод `Array.some()`",
        desc: `Метод \`Array.some(callback, thisArg)\` проверяет, удовлетворяет ли хотя бы один элемент массива предоставленной функции. Возвращает \`true\`, если такой элемент найден, и \`false\`, если нет.`,
      },
      {
        title: "Метод `Array.every()`",
        desc: `Метод \`Array.every(callback, thisArg)\` проверяет, удовлетворяют ли все элементы массива предоставленной функции. Возвращает \`true\`, если все элементы соответствуют, и \`false\`, если нет.`,
      },
      {
        title: "Метод `Array.sort()`",
        desc: `Метод \`Array.sort(compareFunction)\` сортирует элементы массива на месте и возвращает отсортированный массив. Если функция сравнения не указана, элементы сортируются как строки.`,
      },
      {
        title: "Метод `Array.reverse()`",
        desc: `Метод \`Array.reverse()\` изменяет порядок элементов массива на обратный и возвращает изменённый массив.`,
      },
      {
        title: "Метод `Array.includes()`",
        desc: `Метод \`Array.includes(valueToFind, fromIndex)\` проверяет, содержит ли массив указанный элемент \`valueToFind\`, начиная с индекса \`fromIndex\`. Возвращает \`true\`, если элемент найден, и \`false\`, если нет.`,
      },
      {
        title: "Метод `Array.join()`",
        desc: `Метод \`Array.join(separator)\` объединяет все элементы массива в строку, используя указанный разделитель \`separator\`. По умолчанию элементы разделяются запятой.`,
      },
      {
        title: "Метод `Array.copyWithin()`",
        desc: `Метод \`Array.copyWithin(target, start, end)\` копирует часть массива в другое место в том же массиве. Не изменяет длину массива.`,
      },
      {
        title: "Метод `Array.fill()`",
        desc: `Метод \`Array.fill(value, start, end)\` заменяет все элементы массива от индекса \`start\` до \`end\` на указанное значение \`value\`. Если \`start\` и \`end\` не указаны, заполняется весь массив.`,
      },
      {
        title: "Метод `Array.from()`",
        desc: `Метод \`Array.from(arrayLike, mapFunction, thisArg)\` создаёт новый массив из массивоподобного объекта или итерируемого объекта. Можно также использовать функцию отображения \`mapFunction\` для преобразования элементов.`,
      },
    ],
  },
  {
    id: 10,
    category: 3,
    ComponentName: "Json",
    name: "JSON",
    path: "json",
    nextPath: "/js/strNum",
    data: [
      {
        title: "JSON",
        desc: `JSON (JavaScript Object Notation) — это формат обмена данными, который представляет собой текстовый формат для хранения и передачи данных. Он используется для обмена данными между клиентом и сервером. JSON легко читается человеком и парсится программами.`,
      },
      {
        title: "Метод `JSON.parse()`",
        desc: `Метод \`JSON.parse(text, reviver)\` преобразует строку в формате JSON в JavaScript-объект. При этом можно использовать функцию \`reviver\`, чтобы изменить или фильтровать значения во время преобразования.`,
      },
      {
        title: "Метод `JSON.stringify()`",
        desc: `Метод \`JSON.stringify(value, replacer, space)\` преобразует JavaScript-объект в строку JSON. Можно использовать параметр \`replacer\` для фильтрации значений, а параметр \`space\` для добавления отступов для форматирования строки.`,
      },
      {
        title: "Функция `setTimeout()`",
        desc: `Функция \`setTimeout(callback, delay)\` запускает функцию \`callback\` через заданное время \`delay\` (в миллисекундах). Возвращает идентификатор таймера, который можно использовать для его отмены с помощью \`clearTimeout\`. `,
      },
      {
        title: "Функция `setInterval()`",
        desc: `Функция \`setInterval(callback, interval)\` запускает функцию \`callback\` через определённые интервалы времени \`interval\` (в миллисекундах). Возвращает идентификатор интервала, который можно использовать для его отмены с помощью \`clearInterval\`. `,
      },
      {
        title: "Функция `clearTimeout()`",
        desc: `Функция \`clearTimeout(timeoutId)\` отменяет таймер, заданный с помощью \`setTimeout()\`, используя идентификатор таймера \`timeoutId\`. Таймер больше не будет выполнен.`,
      },
      {
        title: "Функция `clearInterval()`",
        desc: `Функция \`clearInterval(intervalId)\` отменяет интервал, заданный с помощью \`setInterval()\`, используя идентификатор интервала \`intervalId\`. Интервал больше не будет продолжать выполнение.`,
      },
    ],
  },
  {
    id: 11,
    category: 3,
    ComponentName: "StrNum",
    name: "String/number",
    path: "strNum",
    nextPath: "/js/storage",
    data: [
      {
        title: "Строки (String)",
        desc: `Строки в JavaScript представляют собой последовательности символов, используемые для хранения и работы с текстовой информацией. Они являются примитивным типом данных и обладают множеством встроенных методов.`,
      },
      {
        title: "Метод `String.length`",
        desc: `Свойство \`String.length\` возвращает количество символов в строке.`,
      },
      {
        title: "Метод `String.charAt()`",
        desc: `Метод \`String.charAt(index)\` возвращает символ строки по указанному индексу \`index\`. Если индекс выходит за пределы строки, возвращает пустую строку.`,
      },
      {
        title: "Метод `String.includes()`",
        desc: `Метод \`String.includes(searchString, position)\` проверяет, содержится ли в строке подстрока \`searchString\` начиная с позиции \`position\`. Возвращает \`true\`, если подстрока найдена, и \`false\`, если нет.`,
      },
      {
        title: "Метод `String.indexOf()`",
        desc: `Метод \`String.indexOf(searchValue, fromIndex)\` возвращает индекс первого вхождения подстроки \`searchValue\`, начиная с позиции \`fromIndex\`. Возвращает \`-1\`, если подстрока не найдена.`,
      },
      {
        title: "Метод `String.slice()`",
        desc: `Метод \`String.slice(beginIndex, endIndex)\` возвращает новую строку, содержащую часть исходной строки, начиная с индекса \`beginIndex\` и заканчивая индексом \`endIndex\` (не включая его).`,
      },
      {
        title: "Метод `String.substring()`",
        desc: `Метод \`String.substring(indexStart, indexEnd)\` возвращает новую строку, содержащую символы из исходной строки между индексами \`indexStart\` и \`indexEnd\` (не включая \`indexEnd\`).`,
      },
      {
        title: "Метод `String.toLowerCase()`",
        desc: `Метод \`String.toLowerCase()\` возвращает новую строку, в которой все символы преобразованы в нижний регистр.`,
      },
      {
        title: "Метод `String.toUpperCase()`",
        desc: `Метод \`String.toUpperCase()\` возвращает новую строку, в которой все символы преобразованы в верхний регистр.`,
      },
      {
        title: "Метод `String.trim()`",
        desc: `Метод \`String.trim()\` возвращает новую строку, в которой удалены пробелы с начала и конца строки.`,
      },
      {
        title: "Метод `String.replace()`",
        desc: `Метод \`String.replace(searchValue, newValue)\` возвращает новую строку, в которой первое вхождение \`searchValue\` заменено на \`newValue\`. Если \`searchValue\` является регулярным выражением, заменяются все совпадения.`,
      },
      {
        title: "Метод `String.split()`",
        desc: `Метод \`String.split(separator, limit)\` разбивает строку на массив подстрок, разделённых указанным разделителем \`separator\`. Если \`limit\` указан, возвращается не более \`limit\` элементов.`,
      },
      {
        title: "Метод `String.repeat()`",
        desc: `Метод \`String.repeat(count)\` возвращает новую строку, состоящую из повторяющихся строк \`count\` раз.`,
      },
      {
        title: "Числа (Number)",
        desc: `Числа в JavaScript представляют собой примитивный тип данных для хранения числовых значений. Они включают в себя целые числа, числа с плавающей запятой и специальные значения NaN, Infinity и -Infinity.`,
      },
      {
        title: "Метод `Number.toFixed()`",
        desc: `Метод \`Number.toFixed(digits)\` возвращает строку, представляющую число с фиксированным количеством десятичных знаков \`digits\`. Округляет число до указанного количества знаков после запятой.`,
      },
      {
        title: "Метод `Number.parseFloat()`",
        desc: `Метод \`Number.parseFloat(string)\` преобразует строку \`string\` в число с плавающей запятой. Игнорирует начальные пробелы и останавливается на первом недопустимом символе.`,
      },
      {
        title: "Метод `Number.parseInt()`",
        desc: `Метод \`Number.parseInt(string, radix)\` преобразует строку \`string\` в целое число, используя основание \`radix\` системы счисления (по умолчанию 10).`,
      },
      {
        title: "Метод `Number.isNaN()`",
        desc: `Метод \`Number.isNaN(value)\` проверяет, является ли переданное значение NaN (Not-a-Number). Возвращает \`true\`, если значение NaN, и \`false\`, если нет.`,
      },
    ],
  },
  {
    id: 12,
    category: 3,
    ComponentName: "Storage",
    name: "local/SessionStorage",
    path: "storage",
    nextPath: "/dom/domNav",
    data: [
      {
        title: "localStorage",
        desc: `localStorage предоставляет способ хранения данных в веб-браузере, который сохраняет данные в течение длительного времени. Данные, сохранённые в localStorage, сохраняются даже после закрытия браузера или перезагрузки страницы.`,
      },
      {
        title: "localStorage.setItem - сохраняет данные",
        desc: `Метод \`localStorage.setItem(key, value)\` сохраняет данные в localStorage. Принимает два параметра: \`key\` (ключ, по которому данные будут сохранены) и \`value\` (значение, которое будет сохранено). Значение всегда сохраняется как строка.`,
      },
      {
        title: "localStorage.getItem - возвращает данные",
        desc: `Метод \`localStorage.getItem(key)\` возвращает значение, сохранённое в localStorage по указанному ключу \`key\`. Если данные с таким ключом отсутствуют, возвращает \`null\`.`,
      },
      {
        title: "localStorage-removeItem - удаляет данные",
        desc: `Метод \`localStorage.removeItem(key)\` удаляет данные из localStorage по указанному ключу \`key\`. Если данных с таким ключом нет, метод ничего не делает.`,
      },
      {
        title: "localStorage.clear - удаляет все данные",
        desc: `Метод \`localStorage.clear()\` удаляет все данные из localStorage для текущего домена. Используйте с осторожностью, так как это действие необратимо.`,
      },
      {
        title: "localStorage.key - возвращает имя ключа",
        desc: `Метод \`localStorage.key(index)\` возвращает имя ключа по заданному индексу \`index\`. Индексы начинаются с 0 и идут по порядку. Если индекс выходит за пределы диапазона, возвращает \`null\`.`,
      },
      {
        title: "sessionStorage",
        desc: `sessionStorage предоставляет способ хранения данных в веб-браузере, который сохраняет данные только на время текущей сессии. Данные, сохранённые в sessionStorage, удаляются при закрытии вкладки или окна браузера.`,
      },
      {
        title: "sessionStorage-setItem - сохраняет данные",
        desc: `Метод \`sessionStorage.setItem(key, value)\` сохраняет данные в sessionStorage. Принимает два параметра: \`key\` (ключ, по которому данные будут сохранены) и \`value\` (значение, которое будет сохранено). Значение всегда сохраняется как строка.`,
      },
      {
        title: "sessionStorage-getItem - возвращает данные",
        desc: `Метод \`sessionStorage.getItem(key)\` возвращает значение, сохранённое в sessionStorage по указанному ключу \`key\`. Если данные с таким ключом отсутствуют, возвращает \`null\`.`,
      },
      {
        title: "sessionStorage-removeItem - удаляет данные",
        desc: `Метод \`sessionStorage.removeItem(key)\` удаляет данные из sessionStorage по указанному ключу \`key\`. Если данных с таким ключом нет, метод ничего не делает.`,
      },
      {
        title: "sessionStorage.clear - удаляет все данные",
        desc: `Метод \`sessionStorage.clear()\` удаляет все данные из sessionStorage для текущего домена. Используйте с осторожностью, так как это действие необратимо.`,
      },
      {
        title: "sessionStorage.key - возвращает имя ключа",
        desc: `Метод \`sessionStorage.key(index)\` возвращает имя ключа по заданному индексу \`index\`. Индексы начинаются с 0 и идут по порядку. Если индекс выходит за пределы диапазона, возвращает \`null\`.`,
      },
    ],
  },
  {
    id: 13,
    category: 4,
    ComponentName: "DomNav",
    name: "Навигация в DOM",
    path: "domNav",
    nextPath: "/dom/classList",
    data: [
      {
        title: "document-getElementById - получение элемента по ID",
        desc: `Метод \`document getElementById(id)\` возвращает элемент, соответствующий указанному идентификатору \`id\`. Если такого элемента не существует, возвращает \`null\`.`,
      },
      {
        title: "document-querySelector - первый элемент по CSS-селектору",
        desc: `Метод \`document querySelector(selector)\` возвращает первый элемент, соответствующий заданному CSS-селектору \`selector\`. Если таких элементов нет, возвращает \`null\`.`,
      },
      {
        title: "document-querySelectorAll - все элементы по CSS-селектору",
        desc: `Метод \`document querySelectorAll(selector)\` возвращает NodeList (список узлов) всех элементов, соответствующих заданному CSS-селектору \`selector\`. Если таких элементов нет, возвращает пустой список.`,
      },
      {
        title: "document-getElements ByClassName - элементы по классу",
        desc: `Метод \`document getElements ByClassName(className)\` возвращает HTMLCollection всех элементов, которые имеют указанный класс \`className\`. Это живой список, который обновляется при изменении DOM.`,
      },
      {
        title: "document-getElements ByTagName - элементы по тегу",
        desc: `Метод \`document getElements ByTagName(tagName)\` возвращает HTMLCollection всех элементов с указанным именем тега \`tagName\`. Это живой список, который обновляется при изменении DOM.`,
      },
      {
        title: "element-parentNode - родительский узел",
        desc: `Свойство \`parentNode\` возвращает родительский узел данного элемента. Если родительского узла нет (например, для корневого элемента), возвращает \`null\`.`,
      },
      {
        title: "element-firstChild - первый дочерний узел",
        desc: `Свойство \`firstChild\` возвращает первый дочерний узел данного элемента. Если у элемента нет дочерних узлов, возвращает \`null\`.`,
      },
      {
        title: "element-lastChild - последний дочерний узел",
        desc: `Свойство \`lastChild\` возвращает последний дочерний узел данного элемента. Если у элемента нет дочерних узлов, возвращает \`null\`.`,
      },
      {
        title: "element-previousSibling - предыдущий соседний узел",
        desc: `Свойство \`previousSibling\` возвращает предыдущий соседний узел данного элемента. Если такого узла нет, возвращает \`null\`.`,
      },
      {
        title: "element-nextSibling - следующий соседний узел",
        desc: `Свойство \`nextSibling\` возвращает следующий соседний узел данного элемента. Если такого узла нет, возвращает \`null\`.`,
      },
      {
        title: "element-children - дочерние элементы",
        desc: `Свойство \`children\` возвращает HTMLCollection всех дочерних элементов данного элемента (исключая текстовые узлы и комментарии). Это живой список, который обновляется при изменении DOM.`,
      },
      {
        title: "element-childNodes - все дочерние узлы",
        desc: `Свойство \`childNodes\` возвращает NodeList всех дочерних узлов данного элемента, включая текстовые узлы и комментарии. Это живой список, который обновляется при изменении DOM.`,
      },
      {
        title: "element-closest - ближайший предок по селектору",
        desc: `Метод \`element.closest(selector)\` возвращает ближайший родительский элемент (включая сам элемент), который соответствует заданному CSS-селектору \`selector\`. Если такого элемента нет, возвращает \`null\`.`,
      },
      {
        title: "element-parentElement - родительский элемент",
        desc: `Свойство \`parentElement\` возвращает родительский элемент данного элемента. В отличие от \`parentNode\`, возвращает \`null\`, если родительский узел не является элементом.`,
      },
      {
        title: "element-contains - проверка наличия потомка",
        desc: `Метод \`element.contains(node)\` проверяет, является ли \`node\` потомком данного элемента. Возвращает \`true\`, если является, и \`false\`, если нет.`,
      },
    ],
  },
  {
    id: 14,
    category: 4,
    ComponentName: "ClassListModule",
    name: "classList",
    path: "classList",
    nextPath: "/dom/manipulation",
    data: [
      {
        title: "add - добавляет класс",
        desc: `Метод \`classList.add(className)\` добавляет указанный класс \`className\` к элементу. Если класс уже существует, метод не добавляет его снова.`,
      },
      {
        title: "remove - удаляет класс",
        desc: `Метод \`classList.remove(className)\` удаляет указанный класс \`className\` из элемента. Если такого класса нет, метод ничего не делает.`,
      },
      {
        title: "toggle - переключает класс",
        desc: `Метод \`classList.toggle(className, [force])\` переключает указанный класс \`className\` на элементе. Если класс присутствует, метод его удаляет, если отсутствует — добавляет. Необязательный параметр \`force\` (булево значение) указывает, должен ли класс быть добавлен или удалён.`,
      },
      {
        title: "contains - проверяет наличие класса",
        desc: `Метод \`classList.contains(className)\` проверяет, есть ли указанный класс \`className\` у элемента. Возвращает \`true\`, если класс присутствует, и \`false\`, если нет.`,
      },
      {
        title: "replace - заменяет класс",
        desc: `Метод \`classList.replace(oldClass, newClass)\` заменяет существующий класс \`oldClass\` на новый класс \`newClass\`. Если класс \`oldClass\` отсутствует, ничего не происходит.`,
      },
      {
        title: "length - количество классов",
        desc: `Свойство \`classList.length\` возвращает количество классов, назначенных элементу.`,
      },
      {
        title: "item - получение класса по индексу",
        desc: `Метод \`classList.item(index)\` возвращает класс по указанному индексу \`index\`. Индексы начинаются с 0. Если индекс выходит за пределы диапазона, возвращает \`null\`.`,
      },
    ],
  },
  {
    id: 15,
    category: 4,
    ComponentName: "Manipulation",
    name: "Манипуляция в DOM",
    path: "manipulation",
    nextPath: "/dom/prom",
    data: [
      {
        title: "innerHTML - вставка HTML-контента",
        desc: `Свойство \`innerHTML\` позволяет получить или установить HTML-содержимое элемента. Устанавливая \`innerHTML\`, вы можете добавить HTML-разметку или заменить существующую разметку внутри элемента.`,
      },
      {
        title: "outerHTML - вставка и замена всего элемента",
        desc: `Свойство \`outerHTML\` позволяет получить или заменить сам элемент, включая его HTML-теги. Устанавливая \`outerHTML\`, вы можете заменить элемент и его содержимое новыми HTML-тегами.`,
      },
      {
        title: "textContent - вставка текстового контента",
        desc: `Свойство \`textContent\` позволяет получить или установить текстовое содержимое элемента. В отличие от \`innerHTML\`, оно обрабатывает текст как простую строку, без интерпретации HTML-тегов.`,
      },
      {
        title: "createElement - создание нового элемента",
        desc: `Метод \`document createElement(tagName)\` создаёт новый элемент с указанным тегом \`tagName\`. Новый элемент создаётся, но не добавляется на страницу до тех пор, пока он не будет вставлен в DOM.`,
      },
      {
        title: "append - добавление узлов",
        desc: `Метод \`element.append(...nodes)\` добавляет один или несколько узлов или строки в конец списка дочерних элементов указанного родительского элемента. Этот метод поддерживает как узлы, так и строки в качестве параметров.`,
      },
      {
        title: "appendChild - добавление дочернего элемента",
        desc: `Метод \`element.appendChild(node)\` добавляет узел \`node\` в конец дочерних элементов указанного родительского элемента. В отличие от \`append\`, этот метод принимает только один узел и не поддерживает строки.`,
      },
      {
        title: "prepend - добавление узлов в начало",
        desc: `Метод \`element.prepend(...nodes)\` добавляет один или несколько узлов или строки в начало списка дочерних элементов указанного родительского элемента. Этот метод поддерживает как узлы, так и строки в качестве параметров.`,
      },
      {
        title: "remove - удаление элемента",
        desc: `Метод \`element.remove()\` удаляет элемент из DOM. Он удаляет элемент, на котором вызывается метод, из родительского элемента.`,
      },
    ],
  },
  {
    id: 16,
    category: 4,
    ComponentName: "Prom",
    name: "Promise/try-catch",
    path: "prom",
    nextPath: "/dom/eventloop",
    data: [
      {
        title: "Promise - создание промиса",
        desc: `Конструктор \`new Promise(executor)\` создаёт новый объект Promise. Функция \`executor\` выполняется немедленно и принимает два аргумента: \`resolve\` и \`reject\`. \`resolve(value)\` — функция, которая должна быть вызвана при успешном завершении операции и передать результат; \`reject(error)\` — функция, которая должна быть вызвана при ошибке и передать причину отказа (ошибку).`,
      },
      {
        title: "then - обработка успешного завершения",
        desc: `Метод \`promise.then(onFulfilled, onRejected)\` добавляет обработчики для выполнения при успешном завершении промиса или при его отказе. \`onFulfilled(value)\` вызывается с результатом, если промис был решён успешно. \`onRejected(error)\` вызывается с причиной отказа, если промис был отклонён.`,
      },
      {
        title: "catch - обработка ошибок",
        desc: `Метод \`promise.catch(onRejected)\` добавляет обработчик, который будет вызван в случае отклонения промиса. Он аналогичен вызову \`then(null, onRejected)\`.`,
      },
      {
        title: "finally - завершающий обработчик",
        desc: `Метод \`promise.finally(onFinally)\` добавляет обработчик, который будет выполнен после завершения промиса, независимо от того, завершился он успешно или с ошибкой. \`onFinally()\` не принимает аргументов и служит для выполнения завершающих операций.`,
      },
    ],
  },
  {
    id: 17,
    category: 4,
    ComponentName: "EventLoop",
    name: "event loop",
    path: "eventloop",
    nextPath: "/dom/fetch",
    data: [
      {
        title: "1. Выполнение синхронного кода",
        desc: `JavaScript исполняет весь синхронный код по очереди, добавляя вызовы функций в стек вызовов (Call Stack). В этом шаге выполняется основной код и функции без ожидания.`,
      },
      {
        title: "2. Проверка очереди микрозадач (Microtask Queue)",
        desc: `После завершения текущего стека вызовов Event Loop проверяет очередь микрозадач. Микрозадачи, такие как обработчики, добавленные с помощью \`Promise.then\`, \`catch\`, \`finally\` или \`queueMicrotask\`, выполняются перед любыми задачами из очереди задач (Task Queue). Все микрозадачи должны быть выполнены, прежде чем двигаться дальше.`,
      },
      {
        title: "3. Выполнение макрозадач (Task Queue)",
        desc: `После выполнения всех микрозадач Event Loop проверяет очередь задач (Task Queue). Макрозадачи включают события, обработчики событий, асинхронные вызовы, такие как \`setTimeout\` и \`setInterval\`, а также ввод/вывод. Самая первая задача из этой очереди помещается в стек вызовов и исполняется.`,
      },
      {
        title: "4. Повторение цикла",
        desc: `После выполнения всех задач из очереди задач и микрозадач Event Loop снова начинает процесс с первого шага — проверки стека вызовов и выполнения оставшегося кода. Это повторяется до тех пор, пока приложение работает.`,
      },
    ],
  },
  {
    id: 18,
    category: 4,
    ComponentName: "FetchApi",
    name: "fetcg/axios",
    path: "fetch",
    nextPath: "/react/hooks",
    data: [
      {
        title: "fetch - выполнение HTTP-запросов",
        desc: `Метод \`fetch(url, options)\` используется для выполнения HTTP-запросов. Он принимает два параметра: \`url\` — адрес ресурса и \`options\` (необязательный) — объект с настройками запроса. Возвращает промис, который разрешается в объект \`Response\`, представляющий ответ на запрос.`,
      },
      {
        title: "Response.json - парсинг JSON",
        desc: `Метод \`response.json()\` используется для парсинга тела ответа в формате JSON. Возвращает промис, который разрешается в объект JavaScript, созданный из JSON-данных.`,
      },
      {
        title: "Request.method - метод запроса",
        desc: `Свойство \`request.method\` у объекта \`Request\` указывает HTTP-метод, используемый в запросе (например, 'GET', 'POST'). Метод указывается в объекте \`options\` при вызове \`fetch\`.`,
      },
      {
        title: "Request.headers - заголовки запроса",
        desc: `Свойство \`request.headers\` у объекта \`Request\` содержит заголовки запроса. Заголовки могут быть переданы в объекте \`options\` при вызове \`fetch\`, либо использованы по умолчанию.`,
      },
      {
        title: "Request.body - тело запроса",
        desc: `Свойство \`request.body\` у объекта \`Request\` содержит тело запроса. Тело запроса может быть задано в объекте \`options\` при вызове \`fetch\`, например, для отправки данных в запросе POST.`,
      },
      {
        title: "fetch - метод GET",
        desc: `Метод \`fetch(url)\` с параметрами по умолчанию выполняет HTTP-запрос типа GET, который используется для получения данных с сервера.`,
      },
      {
        title: "fetch - метод PATCH",
        desc: `Метод \`fetch(url, { method: 'PATCH', body: data })\` выполняет HTTP-запрос типа PATCH. Этот метод используется для частичного обновления данных на сервере. В параметре \`body\` указывается обновлённые данные, которые будут применены к существующему ресурсу.`,
      },
      {
        title: "fetch - метод POST",
        desc: `Метод \`fetch(url, { method: 'POST', body: data })\` выполняет HTTP-запрос типа POST. Этот метод используется для отправки данных на сервер. В параметре \`body\` указывается данные, которые будут отправлены на сервер (например, JSON или форма).`,
      },
      {
        title: "fetch - метод PUT",
        desc: `Метод \`fetch(url, { method: 'PUT', body: data })\` выполняет HTTP-запрос типа PUT. Этот метод используется для обновления данных на сервере. В параметре \`body\` указывается обновлённые данные, которые будут отправлены на сервер.`,
      },
      {
        title: "fetch - метод DELETE",
        desc: `Метод \`fetch(url, { method: 'DELETE' })\` выполняет HTTP-запрос типа DELETE. Этот метод используется для удаления данных на сервере. Параметр \`body\` обычно не используется с методом DELETE, но его можно указать при необходимости.`,
      },
      {
        title: "axios.request - метод REQUEST",
        desc: `Метод \`axios.request(config)\` используется для выполнения HTTP-запроса с полной конфигурацией. Этот метод позволяет указать URL, метод, заголовки, данные и другие параметры запроса.`,
      },
      {
        title: "axios.create - создание экземпляра",
        desc: `Метод \`axios.create(config)\` используется для создания нового экземпляра Axios с предустановленными настройками. Возвращает новый экземпляр Axios, который можно использовать для выполнения запросов с указанными настройками.`,
      },
      {
        title: "axios.interceptors - перехватчики",
        desc: `Axios позволяет добавлять перехватчики запросов и ответов с помощью \`axios.interceptors.request.use\` и \`axios.interceptors.response.use\`. Перехватчики позволяют выполнять действия до отправки запроса или после получения ответа.`,
      },
      {
        title: "axios.defaults - настройки по умолчанию",
        desc: `Объект \`axios.defaults\` используется для указания глобальных настроек, которые будут применяться ко всем запросам, выполненным с помощью Axios. Например, можно указать базовый URL, заголовки по умолчанию и другие параметры.`,
      },
    ],
  },
  {
    id: 19,
    category: 5,
    ComponentName: "Hooks",
    name: "Хуки",
    path: "hooks",
    nextPath: "/react/route",
    data: [
      {
        title: "useState - управление состоянием",
        desc: `Хук \`useState(initialState)\` позволяет добавить состояние в функциональные компоненты. При вызове он возвращает массив с двумя элементами: текущее состояние и функция для его обновления. \`initialState\` задаёт начальное значение состояния.`,
      },
      {
        title: "useEffect - побочные эффекты",
        desc: `Хук \`useEffect(callback, [dependencies])\` позволяет выполнять побочные эффекты в функциональных компонентах, такие как получение данных, подписки или манипуляции с DOM. \`callback\` выполняется после рендеринга компонента. \`[dependencies]\` — массив зависимостей, который определяет, когда \`callback\` должен выполняться.`,
      },
      {
        title: "useContext - доступ к контексту",
        desc: `Хук \`useContext(Context)\` позволяет получить значение из контекста. Контекст создаётся с помощью \`React.createContext\` и используется для передачи данных через дерево компонентов без необходимости прокидывания пропсов.`,
      },
      {
        title: "useReducer - управление состоянием с редьюсером",
        desc: `Хук \`useReducer(reducer, initialState)\` используется для управления состоянием с помощью редьюсера, что может быть полезно для сложного состояния. \`reducer\` — функция, которая принимает текущее состояние и действие, и возвращает новое состояние. \`initialState\` задаёт начальное состояние.`,
      },
      {
        title: "useMemo - мемоизация значений",
        desc: `Хук \`useMemo(callback, [dependencies])\` позволяет мемоизировать значения, чтобы избежать их перерасчёта при каждом рендеринге. \`callback\` выполняется только при изменении значений в массиве \`[dependencies]\`, что может повысить производительность компонентов.`,
      },
      {
        title: "useCallback - мемоизация функций",
        desc: `Хук \`useCallback(callback, [dependencies])\` позволяет мемоизировать функции, чтобы предотвратить их пересоздание при каждом рендеринге компонента. \`callback\` выполняется только при изменении значений в массиве \`[dependencies]\`, что может улучшить производительность при передаче функций в дочерние компоненты.`,
      },
      {
        title: "useRef - доступ к DOM элементам",
        desc: `Хук \`useRef(initialValue)\` возвращает объект с свойством \`current\`, которое может быть использовано для хранения мутируемых значений или ссылок на DOM-элементы. Значение \`current\` сохраняется между рендерами и не вызывает повторный рендер компонента при его изменении.`,
      },
    ],
  },
  {
    id: 20,
    category: 5,
    ComponentName: "Rut",
    name: "React-router",
    path: "route",
    nextPath: "/",
    data: [
      {
        title: "BrowserRouter - контейнер маршрутизации",
        desc: `Компонент \`<BrowserRouter>\` используется для оборачивания приложения и управления маршрутизацией с помощью HTML5 History API. Он предоставляет контекст маршрутизации для всех дочерних компонентов. Обычно используется как корневой компонент приложения.`,
      },
      {
        title: "Routes - определение маршрутов",
        desc: `Компонент \`<Routes>\` используется для определения маршрутов и их соответствующих компонентов. Он заменяет старый компонент \`<Switch>\`. Внутри \`<Routes>\` используются компоненты \`<Route>\` для указания, какой компонент должен рендериться для каждого пути.`,
      },
      {
        title: "Route - определение маршрутов",
        desc: `Компонент \`<Route>\` определяет, какой компонент должен быть отрендерен для заданного пути. Используется внутри \`<Routes>\`. Пример: \`<Route path="/" element={<Home />} />\` указывает, что компонент \`<Home>\` должен быть отрендерен для пути \`/\`.`,
      },
      {
        title: "Link - навигация между страницами",
        desc: `Компонент \`<Link>\` используется для создания ссылок, которые позволяют пользователям перемещаться между различными маршрутами в приложении. Он заменяет стандартный тег \`<a>\` и предотвращает перезагрузку страницы.`,
      },
      {
        title: "NavLink - активные ссылки",
        desc: `Компонент \`<NavLink>\` аналогичен \`<Link>\`, но позволяет добавлять активные стили к текущему маршруту. Это полезно для отображения активного состояния навигационного элемента.`,
      },
      {
        title: "useNavigate - программная навигация",
        desc: `Хук \`useNavigate()\` предоставляет функцию для программной навигации в приложении. Используется для выполнения навигации в коде, например, при отправке формы или выполнении каких-то действий. Возвращает функцию, которая принимает путь и параметры навигации.`,
      },
      {
        title: "useLocation - доступ к информации о маршруте",
        desc: `Хук \`useLocation()\` предоставляет информацию о текущем местоположении в приложении, такую как текущий путь и состояние. Это полезно для выполнения действий в зависимости от текущего маршрута.`,
      },
      {
        title: "useParams - доступ к параметрам маршрута",
        desc: `Хук \`useParams()\` позволяет получить параметры из URL. Это полезно для работы с динамическими маршрутами, где путь содержит параметры, такие как ID или имена. Возвращает объект с параметрами маршрута.`,
      },
      {
        title: "Outlet - отображение вложенных маршрутов",
        desc: `Компонент \`<Outlet>\` используется для отображения дочерних маршрутов внутри родительского маршрута. Это позволяет создавать вложенные маршруты и отображать их в определённых областях компонента.`,
      },
    ],
  },
];